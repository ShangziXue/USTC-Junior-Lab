# -*- coding: utf-8 -*-
# lab4-PB15111662
# environment:python3.5 

import math

ERROR = 0.0000000001

def func(x):
	return pow(x, 3.0) / 3.0 - x

def derivative(x):
	return pow(x, 2.0) - 1.0


def Newton(x0):
	x, k = x0, 0
	error = float('inf')
	while error > ERROR:
		x, x_, k = x - func(x) / derivative(x), x, k + 1
		error = math.fabs(x - x_)
	return x, k

def Secant(x0, x1):
	x, x_, k = x1, x0, 0
	error = float('inf')
	while error > ERROR:
		x, x_, k = x - func(x) * (x - x_) / (func(x) - func(x_)), x, k + 1
		error = math.fabs(x - x_)
	return x, k

Newton_init = [0.1, 0.2, 0.9, 9.0]
Secant_init = [(0.0, 0.1), (0.1, 0.2), (0.2, 0.9), (8.0, 9.0)]

print('Newton迭代，初值、根和迭代步数：')
for init in Newton_init:
	x, k = Newton(init)
	print('初值 %-.1f' % init + '，%-16.15e' % x + '，%-2d' % k)

print('弦截法，初值、根和迭代步数：')
for init in Secant_init:
	x, k = Secant(init[0], init[1])
	print('初值 %-.1f, %-.1f' % init + '，%-16.15e' % x + '，%-2d' % k)


# output
# Newton迭代，初值、根和迭代步数：
# 初值 0.1，0.000000000000e+00，4
# 初值 0.2，0.000000000000e+00，4
# 初值 0.9，-1.732050807569e+00，7
# 初值 9.0，1.732050807569e+00，10
# 弦截法，初值、根和迭代步数：
# 初值 0.0, 0.1，0.000000000000e+00，2
# 初值 0.1, 0.2，9.441607532742e-21，4
# 初值 0.2, 0.9，1.232595164408e-32，6
# 初值 8.0, 9.0，1.732050807569e+00，13

# 分析实验结果
# 1.根据实验结果，无论是牛顿法还是弦截法，最后求得的根都与初始值有关。
# 待求解函数的根有三个，分别为正负根号三和0，当初始点选取在0.1和0.2时，
# 由于在零根附近，所以在用牛顿法和弦截法迭代时最后会收敛到0这个根，即得到根的结果近似为0；
# 当初始点选取在0.9处时，根据原函数可知该点是在极小值附近，即0.9处的导数值很小，所以用牛顿法
# 从该点会跳到负半轴，从而更靠近负根号3这个根，最后收敛到这个根。弦解法由于指定了0.8和0.9两个
# 初始化的点，所以会向0根靠近，从而收敛到0；
# 当初始点选取在9时，其更靠近根号三这个根，所以牛顿法和弦截法会向这个根收敛。
# 2.由于对于实验中的函数，迭代次数较少即可收敛，并不能明显看出牛顿法和弦截法的收敛速度上明显的
# 差距，根据结果，可知在初始点比较靠近根时（即较少步就收敛），弦截法和牛顿法收敛速度接近。
# 当初始点距离根较远时，牛顿法是按照导数移动，相比于弦截法，其收敛速度更快，需要迭代的步数更少。